[
  {
    "path": "posts/2021-06-27-modelling-networks-with-bergm-package/",
    "title": "Estimating network's parameters with Bergm package",
    "description": "Tutorial: How to model Lazega network using Bergm package and its web interface.",
    "author": [
      {
        "name": "Pawel Piela",
        "url": {}
      }
    ],
    "date": "2021-06-27",
    "categories": [
      "ergm",
      "Bergm",
      "complex networks"
    ],
    "contents": "\nNetwork science aims to quantify the processes responsible for creating connections (links) between nodes (actors, vertices) of the network. The network is a relational structure with nodes representing computers, people, proteins, etc., connected by links symbolising connections, friendships or interactions between them.\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\n\\nvar dataEdges=[{\\\"source\\\":0,\\\"target\\\":1},{\\\"source\\\":1,\\\"target\\\":2}];\\nvar dataNodes=[{\\\"name\\\":\\\"John\\\", \\\"id\\\":0},{\\\"name\\\":\\\"Abigail\\\", \\\"id\\\":1},{\\\"name\\\":\\\"Neil\\\", \\\"id\\\":2}, \\n               {\\\"name\\\":\\\"Peter\\\", \\\"id\\\":3}];\\n\\ndrag = simulation => {\\n  \\n  function dragstarted(d) {\\n    //if (!event.active) simulation.alphaTarget(0.3).restart();\\n    simulation.alphaTarget(0.3).restart();\\n    d.fx = d.x; //event.subject.x;\\n    d.fy = d.y; //event.subject.y;\\n  }\\n  \\n  function dragged(d) {\\n    //var pos = d3.mouse(svg.node());\\n    d.fx = d3.event.x;\\n    d.fy = d3.event.y;\\n  }\\n  \\n  function dragended(d) {\\n    //if (!event.active) simulation.alphaTarget(0);\\n    simulation.alphaTarget(0);\\n    d.fx = null;\\n    d.fy = null;\\n  }\\n  \\n  return d3.drag()\\n      .on(\\\"start\\\", dragstarted)\\n      .on(\\\"drag\\\", dragged)\\n      .on(\\\"end\\\", dragended);\\n}\\n\\nfunction chartFun() {\\n  //var width=600, height=600;\\n  //var svg = d3.select('body').append('svg').attr('width', width).attr('height', height);\\n  var color = d3.scaleOrdinal(d3.schemeSet2);\\n\\n  const simulation = d3.forceSimulation()\\n      .force(\\\"charge\\\", d3.forceManyBody()\\n             .strength(-100))\\n      .force(\\\"link\\\", d3.forceLink()\\n             .id(d => d.id))\\n      .force(\\\"x\\\", d3.forceX())\\n      .force(\\\"y\\\", d3.forceY())\\n      .force(\\\"center\\\", d3.forceCenter(width / 2, height / 2))\\n      .on(\\\"tick\\\", ticked);\\n\\n  let link = svg.append(\\\"g\\\")\\n      .attr(\\\"stroke\\\", \\\"#000\\\")\\n      .attr(\\\"stroke-width\\\", 1.5)\\n      .attr(\\\"stroke-opacity\\\", .3)\\n    .selectAll(\\\"line\\\");\\n\\n  let node = svg.append(\\\"g\\\")\\n      .attr(\\\"stroke\\\", \\\"#fff\\\")\\n      .attr(\\\"stroke-width\\\", 1.5)\\n      .attr(\\\"cursor\\\", \\\"crosshair\\\")\\n    .selectAll(\\\"circle\\\");\\n\\n  function ticked() {\\n\\n    node.attr(\\\"cx\\\", d => d.x)\\n        .attr(\\\"cy\\\", d => d.y)\\n\\n    link.attr(\\\"x1\\\", d => d.source.x)\\n        .attr(\\\"y1\\\", d => d.source.y)\\n        .attr(\\\"x2\\\", d => d.target.x)\\n        .attr(\\\"y2\\\", d => d.target.y);\\n  }\\n\\n  return Object.assign( svg.node(), {\\n    update({nodes, links, covariate}) {\\n      const old = new Map(node.data().map(d => [d.id, d]));\\n      nodes = nodes.map(d => Object.assign(old.get(d.id) || {}, d));\\n      links = links.map(d => Object.assign({}, d));\\n\\n      node = node\\n        .data(nodes, d => d.id)\\n        .join(enter => enter.append(\\\"circle\\\")\\n          .attr(\\\"r\\\", 8)\\n          .attr(\\\"fill\\\", d => color(d[covariate])))\\n        .call(node => node.append(\\\"title\\\").text(d => covariate + \\\": \\\" + d[covariate]))\\n        .call(drag(simulation));\\n\\n      link = link\\n        .data(links, d => [d.source, d.target])\\n        .join(\\\"line\\\");\\n\\n      simulation.nodes(nodes);\\n      simulation.force(\\\"link\\\").links(links);\\n      simulation.alpha(1).restart();\\n  }});\\n}\\n\\nfunction update() {\\n  const nodes = dataNodes;\\n  const links = dataEdges;\\n  const covariate = \\\"name\\\"; //\\\"Age\\\",\\\"Gender\\\",\\\"Office\\\",\\\"Practice\\\",\\\"School\\\",\\\"vertex.names\\\",\\\"Years\\\" \\n\\n  chartObj = chartFun();\\n  chartObj.update({nodes, links, covariate});\\n}\\n\\n\\nupdate();\\n\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\n\nInteractive plot of a simple network with four actors and the friendship relationships between them.\n\nThanks to the recent development of more computationally efficient estimation methods with better convergence, Exponential Random Graphs are gaining popularity among statisticians. Many complex relationships can be modelled and analysed due to a multitude of sufficient statistics (and network sub configurations). Many of them model exogenous properties of the vertices, which do not depend on the structure of the graph. Such covariates might be gender, race, citizenship etc. Endogenous properties specify how the connections between the vertices influence the rest of the graph. Endogenous properties are edge-wise shared partners, k-stars etc.\nThe essence of the ERGMs is to find estimates of the parameters \\(\\boldsymbol\\theta\\) of the model:\n\\[\np(y \\mid \\boldsymbol\\theta) = \\frac{\\exp\\left( \\sum_{i=1}^d\\theta_i g_i(x) \\right)}{z(\\boldsymbol\\theta)}\n\\]\nThe likelihood normalising constant \\(z(\\boldsymbol\\theta) = \\sum\\limits_{y \\in \\mathcal{Y}} \\exp\\left( \\sum_{i=1}^d\\theta_i g_i(x) \\right)\\) depends on the values of the parameter vector \\(\\boldsymbol\\theta \\in \\mathbb{R}^d\\) and is summed over all possible network configurations with \\(2^{\\binom{n}{2}}\\) combinations of edges and links in the undirected network.\nThe first significant steps to develop methods to estimate parameters of such models were MPLE (Maximum Pseudo-Likelihood) (Strauss and Ikeda 1990) and MCMLE methods (Geyer and Thompson 1992). MPLE proved to be biased and lead to underestimated variance. The next breakthrough was possible thanks to the increased computational power of personal computers leading to the popularisation of Bayesian statistics, primarily through the Markow Chain Monte Carlo simulations. The exchange algorithm was developed (Murray, Ghahramani, and MacKay 2006). It dealt with the double-intractability of the posterior distributions by introducing the auxiliary variable \\(y'\\), i.e. the sample of the network, similar to the observed one, which is sampled from the MCMC chain and is either accepted or rejected based on the acceptance probability defined by the Metropolis-Hastings algorithm. Caimo and Friel (2014) improved that algorithm by replacing the exact sample \\(y'\\) with an approximate value based on the samples from the auxiliary chain of samples. This method proved to be state-of-the-art. Bouranis, Friel, and Maire (2017) observed that the distribution of samples drawn from very long chains (thinned to reduce autocorrelation) can be approximated by the pseudo-likelihood method with its density translated and the curvature at the mode transformed. The authors showed that this method is both fast and accurate.\nThe latter two methods, i.e. Approximate Exchange Algorithm with Adaptive Sampling and the modified pseudo-likelihood method, are included in the Bergm package.\nLazega\nOne of the number of network datasets used for illustrative purposes is the lazega dataset (Lazega and others 2001). In this undirected network, nodes represent attorneys, and links represent their collaborative relations. Each node has assigned attributes such as Practice, Office, Gender, Age, Years and School.\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nvar dataNodes, dataEdges;\\n\\nvar edgesPromise = d3.csv('https://raw.githubusercontent.com/mrppdex/mrppdex.github.io/master/dataviz/data/lazegaEdges%401.csv', d3.autoType).then(data => { dataEdges = data });\\nvar nodesPromise = d3.csv('https://raw.githubusercontent.com/mrppdex/mrppdex.github.io/master/dataviz/data/lazegaNodes%402.csv', d3.autoType).then(data => { dataNodes = data });\\n\\ndrag = simulation => {\\n  \\n  function dragstarted(d) {\\n    //if (!event.active) simulation.alphaTarget(0.3).restart();\\n    simulation.alphaTarget(0.3).restart();\\n    d.fx = d.x; //event.subject.x;\\n    d.fy = d.y; //event.subject.y;\\n  }\\n  \\n  function dragged(d) {\\n    //var pos = d3.mouse(svg.node());\\n    d.fx = d3.event.x;\\n    d.fy = d3.event.y;\\n  }\\n  \\n  function dragended(d) {\\n    //if (!event.active) simulation.alphaTarget(0);\\n    simulation.alphaTarget(0);\\n    d.fx = null;\\n    d.fy = null;\\n  }\\n  \\n  return d3.drag()\\n      .on(\\\"start\\\", dragstarted)\\n      .on(\\\"drag\\\", dragged)\\n      .on(\\\"end\\\", dragended);\\n}\\n\\nfunction chartFun() {\\n  //var width=600, height=600;\\n  //var svg = d3.select('body').append('svg').attr('width', width).attr('height', height);\\n  var color = d3.scaleOrdinal(d3.schemeSet2);\\n\\n  const simulation = d3.forceSimulation()\\n      .force(\\\"charge\\\", d3.forceManyBody()\\n             .strength(-100))\\n      .force(\\\"link\\\", d3.forceLink()\\n             .id(d => d.id))\\n      .force(\\\"x\\\", d3.forceX())\\n      .force(\\\"y\\\", d3.forceY())\\n      .force(\\\"center\\\", d3.forceCenter(width / 2, height / 2))\\n      .on(\\\"tick\\\", ticked);\\n\\n  let link = svg.append(\\\"g\\\")\\n      .attr(\\\"stroke\\\", \\\"#000\\\")\\n      .attr(\\\"stroke-width\\\", 1.5)\\n      .attr(\\\"stroke-opacity\\\", .3)\\n    .selectAll(\\\"line\\\");\\n\\n  let node = svg.append(\\\"g\\\")\\n      .attr(\\\"stroke\\\", \\\"#fff\\\")\\n      .attr(\\\"stroke-width\\\", 1.5)\\n      .attr(\\\"cursor\\\", \\\"crosshair\\\")\\n    .selectAll(\\\"circle\\\");\\n\\n  function ticked() {\\n\\n    node.attr(\\\"cx\\\", d => d.x)\\n        .attr(\\\"cy\\\", d => d.y)\\n\\n    link.attr(\\\"x1\\\", d => d.source.x)\\n        .attr(\\\"y1\\\", d => d.source.y)\\n        .attr(\\\"x2\\\", d => d.target.x)\\n        .attr(\\\"y2\\\", d => d.target.y);\\n  }\\n\\n  return Object.assign( svg.node(), {\\n    update({nodes, links, covariate}) {\\n      const old = new Map(node.data().map(d => [d.id, d]));\\n      nodes = nodes.map(d => Object.assign(old.get(d.id) || {}, d));\\n      links = links.map(d => Object.assign({}, d));\\n\\n      node = node\\n        .data(nodes, d => d.id)\\n        .join(enter => enter.append(\\\"circle\\\")\\n          .attr(\\\"r\\\", 8)\\n          .attr(\\\"fill\\\", d => color(d[covariate])))\\n        .call(node => node.append(\\\"title\\\").text(d => covariate + \\\": \\\" + d[covariate]))\\n        .call(drag(simulation));\\n\\n      link = link\\n        .data(links, d => [d.source, d.target])\\n        .join(\\\"line\\\");\\n\\n      simulation.nodes(nodes);\\n      simulation.force(\\\"link\\\").links(links);\\n      simulation.alpha(1).restart();\\n  }});\\n}\\n\\nfunction update() {\\n  const nodes = dataNodes;\\n  const links = dataEdges;\\n  const covariate = \\\"Practice\\\"; //\\\"Age\\\",\\\"Gender\\\",\\\"Office\\\",\\\"Practice\\\",\\\"School\\\",\\\"vertex.names\\\",\\\"Years\\\" \\n\\n  chartObj = chartFun();\\n  chartObj.update({nodes, links, covariate});\\n}\\n\\nfunction main() {\\n  Promise.all([nodesPromise, edgesPromise]).then( () => update());\\n}\\n\\nmain();\\n\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\n\nLazega network\n\nThis tutorial will build the model for this dataset using different exogenous and endogenous statistics and configurations. Then, we will trim some of the superfluous terms to obtain the parsimonious model and check its performance by running the goodness-of-fit test.\nModelling\nBergm package is based on the ergm package, a building block of the statnet project. It is the researcher’s responsibility to choose the relevant terms (help(ergm-terms)) that reflect the network’s structure in the best possible way and then analyse the estimated parameters to get insights into processes that took place in creating the observed network.\nThe Bergm package requires the R environment, and it uses script R scripting language. However, the interactive Shiny web application has been created (https://mrppdex.shinyapps.io/bergm-shiny/). Its goal is to facilitate experimentation with networks through the pipeline, which entails model creation, comparison and goodness-of-fit to check the adequacy of the model.\nBergm-shiny web application main screenThe description above the plot of the networks contains information such as the number of nodes, number of links and whether the network is directed or undirected.\nIn this tutorial, we will use the evidence function from the Bergm package. The shiny (Chang et al. 2020) interface allows the practitioner to choose between the evidence function, which is fast and produces less autocorrelated samples and the bergm function, which has good accuracy and convergence but requires many more iterations of the MCMC algorithm in order to get quality samples. In order to choose which function should be used in the estimation process, go to the Options tab and choose the evidence function from the dropdown menu with the label Simulate using:.\nSelect the evidence function in the optionsIn the first attempt, we will choose the following ergm terms in our model:\n\n\nTable 1: Model 1. Descriptions extracted from documentation to the package ergm\n\n\nterms\n\n\ndescription\n\n\ngwesp(decay=0.1, fixed=TRUE)\n\n\nGeometrically weighted edgewise shared partner distribution: This term is just like gwdsp except it adds a statistic equal to the geometrically weighted edgewise (not dyadwise) shared partner distribution with decay parameter decay parameter, which should be non-negative. The value supplied for this parameter may be fixed (if fixed=TRUE), or it may be used instead as the starting value for the estimation of decay in a curved exponential family model (when fixed=FALSE, the default) (see Hunter and Handcock, 2006). This term can be used with directed and undirected networks. For directed networks the geometric weighting is over homogeneous shared partners only (i.e., only partners on a directed two-path connecting the nodes in the edge and in the same direction).\n\n\nedges\n\n\nThis term adds one network statistic equal to the number of edges (i.e. nonzero values) in the network\n\n\nnodematch(attr=“Gender,” diff=FALSE)\n\n\nUniform homophily and differential homophily: The attrname argument is a character vector giving one or more names of attributes in the network’s vertex attribute list. When diff=FALSE, this term adds one network statistic to the model, which counts the number of edges (i,j) for which attrname(i)==attrname(j). (When multiple names are given, the statistic counts only those on which all the named attributes match.) When diff=TRUE, p network statistics are added to the model, where p is the number of unique values of the attrname attribute. The kth such statistic counts the number of edges (i,j) for which attrname(i) == attrname(j) == value(k), where value(k) is the kth smallest unique value of the attrname attribute. If set to non-NULL, the optional keep argument should be a vector of integers giving the values of k that should be considered for matches; other values are ignored (this works for both diff=FALSE and diff=TRUE). For instance, to add two statistics, counting the matches for just the 2nd and 4th categories, use nodematch with diff=TRUE and keep=c(2,4)\n\n\nnodematch(attr=“Age,” diff=FALSE)\n\n\nas above\n\n\nnodematch(attr=“Practice,” diff=TRUE)\n\n\nas above\n\n\nnodematch(attr=“Office,” diff=TRUE, levels=1:2)\n\n\nas above\n\n\nabsdiff(attr=“Age,” pow=1)\n\n\nAbsolute difference: The attrname argument is a character string giving the name of a quantitative attribute in the network’s vertex attribute list. This term adds one network statistic to the model equaling the sum of abs(attrname[i]-attrname[j])^pow for all edges (i,j) in the network.\n\n\nabsdiff(attr=“Years”)\n\n\nas above\n\n\nFirst, (1) we choose the term and pass its arguments and then (2) we add the selected term to the formula.\n Once the estimation is complete, the summary screen is activated.\nEstimation summary screenThe optimal acceptance ratio of the Metropolis-Hastings algorithm should be between 0.2 and 0.3. In this example, however, the acceptance ratio is too low with the value of 0.07, and it can result in poor mixing of the samples. The easiest way to adjust it is to either increase or decrease the V.proposal parameter of the evidence function. It can be adjusted in the options tab. Empirically, the optimal value for the V.proposal argument turns out to be around 0.9. Once the estimation is invoked once again, the acceptance rate is improved with the value of 0.24.\nThe inspection of the Plots tab shows that the parameter’s chains have autocorrelation close to 0 for lags around 60 and the distributions of samples are unimodal.\nAutocorrelation of the parameter samplesThe number of sufficient statistics in the ergm term might be excessive, and some of them may not play a vital role in creating the observed network. The evidence function uses either Chib and Jeliazkov’s (CJ) or Power posterior (PP) methods to estimate the marginal likelihoods. The web application allows checking the evidence with and without selected terms. To select the terms, the user has to click them in the grey box with the formula on the top of the screen. If the term is selected, it will change its colour.\nSelecting terms for model comparisonOnce the terms are selected, we can compare the models with and without them by pressing the COMPARE MODELS button. After the estimation is finished, the Model comparison tab is activated, and the results can be sorted by the value of the log.evidence.\nLog evidence of different modelsIn this example, we can see that the value of the log evidence of our model is equal to -308.9502. Removal of the absdiff(attr=\"Age\", pow=1) improves the model the most. That may indicate that the model without this term might be better. The removal of the edges term significantly lowers the log-likelihood. That means that this term plays a significant role in our model. Because the values of the parameters might be correlated, a good practice is to remove only the worst-performing term and rerun the model comparison. Now, the removal of any of the terms is negatively influencing the model’s log-evidence.\nModel 2Further improvement of the model is impossible, and we can press the Estimate button again to estimate the parsimonious model’s parameters. Once the estimation is complete, the next step is to perform the goodness-of-fit test. It can be accomplished by pressing the GOF button.\n\nNOTE: Model comparison does not update the latest model. Estimations have to be performed before the godness-of-fit tests.\n\nGoodness-of-fit plots of the parsimonous modelAnother approach is to use expert knowledge. In this trivial example, one can assume that working in the same practice influences the connectivity pattern. We can use Practice as the exogenous predictor and gwesp as the endogenous. Even though it has slightly lower log evidence (-298.5582), this model performs better in the goodness-of-fit tests.\nedges+gwesp(decay=0.1, fixed=TRUE)+nodecov(attr=“Practice”)\ntest of the formula\n\n\n\n\nBouranis, Lampros, Nial Friel, and Florian Maire. 2017. “Efficient Bayesian Inference for Exponential Random Graph Models by Correcting the Pseudo-Posterior Distribution.” Social Networks 50: 98–108.\n\n\nCaimo, Alberto, and Nial Friel. 2014. “Bergm: Bayesian Exponential Random Graphs in R.” Journal of Statistical Software 61 (2): 1–25. http://www.jstatsoft.org/v61/i02/.\n\n\nChang, Winston, Joe Cheng, JJ Allaire, Yihui Xie, and Jonathan McPherson. 2020. Shiny: Web Application Framework for r. https://CRAN.R-project.org/package=shiny.\n\n\nGeyer, Charles J, and Elizabeth A Thompson. 1992. “Constrained Monte Carlo Maximum Likelihood for Dependent Data.” Journal of the Royal Statistical Society: Series B (Methodological) 54 (3): 657–83.\n\n\nLazega, Emmanuel, and others. 2001. The Collegial Phenomenon: The Social Mechanisms of Cooperation Among Peers in a Corporate Law Partnership. Oxford University Press on Demand.\n\n\nMurray, Iain, Zoubin Ghahramani, and David MacKay. 2006. “MCMC for Doubly-Intractable Distributions.” arXiv Preprint arXiv:1206.6848.\n\n\nStrauss, David, and Michael Ikeda. 1990. “Pseudolikelihood Estimation for Social Networks.” Journal of the American Statistical Association 85 (409): 204–12.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-07-03T15:13:02+01:00",
    "input_file": "analysis-of-networks-in-r-using-bergm-package.knit.md"
  },
  {
    "path": "posts/2021-05-22-a-brief-introduction-to-d3js-for-data-scientists/",
    "title": "D3.js in Statistics",
    "description": "A brief introduction to D3.js.",
    "author": [
      {
        "name": "Pawel Piela",
        "url": {}
      }
    ],
    "date": "2021-05-22",
    "categories": [
      "d3js"
    ],
    "contents": "\nThose who used both Python or R to perform their statistical inference, or build the machine learning models know, that these environments together with their rich libraries can enable the practitioner to do anything they want. They are great for prototyping and performing experiments. Python in conjunction with Django or Flask can be used to build a fully contained web applications. R with it’s Shiny environment can be used to build interactive dashboards. The shortcoming is that these applications have to run on the server and the resources has to be purchased before the content is shared to a wider audience. One of the solutions to this is to use the audience and their computing power to transform and present the data.\nI have some experience in using R and Python. The main issue I have encountered is that making a move from the experimental phase to publishing is always difficult. After the project is concluded many times it goes back to the drawer, because publishing it would require paying for the computational power or the cloud providers.\nD3.js\nD3.js is a JavaScript framework used to create data driven interactive documents. It is not a graphical library, that can be used to create the interactive content quickly. But once it is mastered, it becomes invaluable help in publishing interactive documents. D3.js is used to create many visually appealing and informative visualisations Observable.\nExample\nHere, we will built an interactive D3.js widget which plots an arbitrary function and calculates the integral under the selected part of the plot. We will use the probability density function of the normal distribution and let the widget calculate the area under two specified x values i.e. the probability.\nfunction f(x) {\n    // standard normal pdf\n    return (1/Math.sqrt(2*Math.PI))*Math.exp(-x*x/2);\n}\n\\[\\begin{equation}\np(x; 0, 1) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left( -\\frac{x^2}{2} \\right)\n\\end{equation}\\]\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\n\\nfunction f(x) {\\n    return (1/Math.sqrt(2*Math.PI))*Math.exp(-x*x/2);\\n}\\n\\nfunction trapInt(fx, dx) {\\n    fxN1 = _.initial(fx);\\n    sumFx = fxN1.reduce((a, v) => a+v);\\n    return dx*(sumFx + (fx[0] + fx[fx.length - 1])/2);\\n}\\n\\nfunction main() {\\n\\n    var dx = 1/50; // granuality of the chart\\n    var margins = {top: 20, right: 10, bottom: 50, left: 10};\\n\\n    var xVals = d3.range(-5, 5, dx); // x\\n    var yVals = xVals.map( x => f(x)); // f(x)\\n\\n    // define the scales\\n    var scX = d3.scaleLinear()\\n      .domain(d3.extent(xVals))\\n      .range([margins.left, width - margins.right])\\n      .nice();\\n\\n    var scY = d3.scaleLinear()\\n      .domain(d3.extent(yVals))\\n      .range([height - margins.bottom, margins.top])\\n      .nice();\\n\\n    // scale x and f(x) to the screen coordinates\\n    var data = xVals.map( (d, i) => [scX(d), scY(yVals[i])]);\\n\\n    // create axes\\n    var xAxis = d3.axisBottom(scX);\\n    var yAxis = d3.axisLeft(scY);\\n    \\n    var foreground  = svg.append(\\\"g\\\").append(\\\"rect\\\")\\n      .attr(\\\"x\\\", 0).attr(\\\"y\\\", 0)\\n      .attr(\\\"width\\\", width).attr(\\\"height\\\", height)\\n      .attr(\\\"opacity\\\", 0);\\n\\n    // add axes to the svg component\\n    svg.append(\\\"g\\\")\\n      .attr(\\\"transform\\\", `translate(0, ${scY(0)})`)\\n      .call(xAxis);\\n    \\n    svg.append(\\\"g\\\")\\n      .attr(\\\"transform\\\", `translate(${scX(0)}, 0)`)\\n      .call(yAxis);\\n\\n\\n    // plot\\n    var lineMkr = d3.line().curve(d3.curveLinear);\\n\\n    // line\\n    var chart = svg.append(\\\"g\\\")\\n      .append(\\\"path\\\")\\n      .attr(\\\"d\\\", lineMkr(data))\\n      .attr(\\\"fill\\\", \\\"none\\\")\\n      .attr(\\\"stroke\\\", \\\"orange\\\")\\n      .attr(\\\"stroke-width\\\", 2);\\n\\n    // cooridiates text\\n    var coord = svg.append(\\\"text\\\")\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    // currently selected value\\n    var circle = svg.append(\\\"g\\\")\\n      .append(\\\"circle\\\")\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    // add event listeners\\n    svg.on(\\\"mousemove\\\", function(event) {\\n        var pt = d3.mouse(svg.node()); // point in the svg component coordinates\\n\\n        // get coordinates of the selected point\\n        var xPos = _.clamp(scX.invert(pt[0]), d3.min(xVals), d3.max(xVals));\\n        var yPos = f(xPos);\\n\\n        // draw \\n        circle\\n          .attr(\\\"r\\\", 5)\\n          .attr(\\\"cx\\\", scX(xPos))\\n          .attr(\\\"cy\\\", scY(yPos))\\n          .attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n        // format displayed coordinates text\\n        var txtPos = `(${d3.format(\\\".2f\\\")(xPos)}, ${d3.format(\\\".2f\\\")(yPos)})`;\\n\\n        coord\\n          .attr(\\\"x\\\", pt[0] > width/2 ? scX(xPos) - 10 : scX(xPos) + 10)\\n          .attr(\\\"y\\\", scY(yPos))\\n          .attr(\\\"visibility\\\", \\\"visible\\\")\\n          .attr(\\\"text-anchor\\\", pt[0] > width/2 ? \\\"end\\\" : \\\"start\\\")\\n          .text(txtPos);\\n    })\\n    .on(\\\"mouseout\\\", function(event) {\\n        // hide the circle an the associated text\\n        circle.attr(\\\"visibility\\\", \\\"hidden\\\");\\n        coord.attr(\\\"visibility\\\", \\\"hidden\\\");\\n    });\\n\\n    // SELECT THE AREA\\n\\n    // define the closed selection\\n    var selectionMaker = d3.line().curve(d3.curveLinearClosed);\\n\\n    var selectionSvg = svg.append(\\\"g\\\")\\n      .append(\\\"path\\\")\\n      .attr(\\\"fill\\\", \\\"steelblue\\\")\\n      .attr(\\\"opacity\\\", .2)\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    // display the area\\n    var txtArea = svg.append(\\\"g\\\")\\n      .append(\\\"text\\\")\\n      .attr(\\\"x\\\", 50)\\n      .attr(\\\"y\\\", 50)\\n      .attr(\\\"font-family\\\", \\\"sans-serif\\\")\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    var dragStart; // x screen coordinate\\n    var dragEnd;  // x screen coordinate\\n    var selectionIdx; // boolean vector indicating which data values are being used in selection\\n    var h0 = scY(0); // y=0 in screen coordinates\\n\\n    // on click hide the selection and displayed area\\n    svg.on(\\\"click\\\", function(event) {\\n        selectionSvg.attr(\\\"visibility\\\", \\\"hidden\\\");\\n        txtArea.attr(\\\"visibility\\\", \\\"hidden\\\");\\n        dragStart = undefined;\\n    });\\n\\n    // define the drag behaviour\\n    var drag = d3.drag()\\n      .on(\\\"start\\\", function(event) {\\n          dragStart = d3.mouse(svg.node())[0];\\n          dragEnd = dragStart;\\n      })\\n      .on(\\\"drag\\\", function(event) {\\n        var pt = d3.mouse(svg.node());\\n\\n        dragEnd = pt[0]; // end selection at the current x poisition\\n        \\n        console.log(\\\"From \\\" + dragStart + \\\" to \\\" + dragEnd);\\n\\n        // to reduce errors due to the granuality\\n        // calculate exact start and end coordinates\\n        var exactStartY = scY(f(scX.invert(dragStart)));\\n        var exactEndY = scY(f(scX.invert(dragEnd)));\\n\\n        // determine which data points are included in the selection\\n        selectionIdx = data.map( d => _.inRange(d[0], dragStart, dragEnd));\\n\\n        // select only relevant slice of the chart data\\n        var selection = data.filter( (d, i) => selectionIdx[i]);\\n\\n        // add the additional points to close the curve\\n        add2Sel = [[dragEnd, h0], [dragStart, h0]].sort( (a, b) => b[0] - a[0]);\\n        addExact = [[dragEnd, exactEndY], [dragStart, exactStartY]].sort( (a, b) => b[0] - a[0]);\\n\\n        add2Sel = _.concat([addExact[0]], add2Sel, [addExact[1]]);\\n        selection = _.concat(selection, add2Sel);\\n        \\n        // draw the selection\\n        selectionSvg\\n          .attr(\\\"d\\\", selectionMaker(selection))\\n          .attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n        // update the position of the circle while dragging\\n\\n        var xPos = _.clamp(scX.invert(pt[0]), d3.min(xVals), d3.max(xVals));\\n        var yPos = f(xPos);\\n\\n        circle\\n            .attr(\\\"r\\\", 5)\\n            .attr(\\\"cx\\\", scX(xPos))\\n            .attr(\\\"cy\\\", scY(yPos))\\n            .attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n        var txtPos = `(${d3.format(\\\".2f\\\")(xPos)}, ${d3.format(\\\".2f\\\")(yPos)})`;\\n\\n        coord\\n            .attr(\\\"x\\\", pt[0] > width/2 ? scX(xPos) - 10 : scX(xPos) + 10)\\n            .attr(\\\"y\\\", scY(yPos))\\n            .attr(\\\"visibility\\\", \\\"visible\\\")\\n            .attr(\\\"text-anchor\\\", pt[0] > width/2 ? \\\"end\\\" : \\\"start\\\")\\n            .text(txtPos);\\n      })\\n      .on(\\\"end\\\", function() {\\n          var fx = yVals.filter( (d, i) => selectionIdx[i] );\\n\\n          if (fx.length > 1) {\\n              txtArea.text(\\\"Selected Area: \\\" + d3.format(\\\".3f\\\")(trapInt(fx, dx)))\\n                .attr(\\\"visibility\\\", \\\"visible\\\");\\n          }\\n      });\\n\\n    // add the dragging behaviour to the svg element\\n    drag(foreground);\\n\\n}\\n\\nmain();\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nThe CDF of the normal distribution does not have a closed form and is defined as:\n\\[\n\\text{CDF} = \\frac{1}{2} \\left[ 1 + \\text{erf} \\left( \\frac{x-\\mu}{\\sigma \\sqrt{2}} \\right) \\right]\n\\] Where,\n\\[\n\\text{erf}\\ z = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2}\\ dt\n\\]\nThe usual method to calculate the CDF would involve using the statistical software such as R, e.g. \\(P(-1 < X < 1) =\\) pnorm(1) - pnorm(-1) = 0.6826895, or can be read from the statistical tables.\nIn this example we use the trapezoidal rule to calculate the approximate area under the curve:\n\\[\n\\int_a^b f(x)\\ dx \\approx \\Delta x \\left( \\sum\\limits_{k=1}^{N-1} x_k + \\frac{f(x_N)+f(x_0)}{2} \\right)\n\\]\nSVG\nD3.js can manipualte the whole DOM document structure, but we are interested in plotting by using the SVG format. First we have to add <svg><\/svg> block to the DOM structure as a child of <body> element.\nvar svg = d3.select(\"body\").append(\"svg\")\n            .attr(\"width\", 600).attr(\"height\", 600);\nHere we selected the <body> element and added <svg> as one of it’s children. We also set the width to 600px and height to 600px.\nAnother very important elements of D3.js scripts are scales\nvar scalerLin = d3.scaleLinear()\n  .domain([0, 1])\n  .range([10, width-10])\n  .nice();\n  \nvar scalerLog = d3.scaleLog()\n  .domain([1e-3, 1e6])\n  .range([10, width-10])\n  .nice();\n  \nvar scalerLinInv = d3.scaleLinear()\n  .domain([0, 1])\n  .range([width-10, 10])\n  .nice();\n\nvar axisLin = d3.axisTop(scalerLin);\nvar axisLog = d3.axisTop(scalerLog);\nvar axisLinInv = d3.axisTop(scalerLinInv);\n\nsvg.append(\"g\").attr(\"transform\", `translate(0, ${height/4})`).call(axisLog);\nsvg.append(\"g\").attr(\"transform\", `translate(0, ${height/2})`).call(axisLin);\nsvg.append(\"g\").attr(\"transform\", `translate(0, ${3*height/4})`).call(axisLinInv);\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nvar scalerLin = d3.scaleLinear()\\n  .domain([0, 1])\\n  .range([10, width-10])\\n  .nice();\\n  \\nvar scalerLog = d3.scaleLog()\\n  .domain([1e-3, 1e6])\\n  .range([10, width-10])\\n  .nice();\\n  \\nvar scalerLinInv = d3.scaleLinear()\\n  .domain([0, 1])\\n  .range([width-10, 10])\\n  .nice();\\n\\nvar axisLin = d3.axisTop(scalerLin);\\nvar axisLog = d3.axisTop(scalerLog);\\nvar axisLinInv = d3.axisTop(scalerLinInv);\\n\\nsvg.append(\\\"g\\\").attr(\\\"transform\\\", `translate(0, ${height/4})`).call(axisLog);\\nsvg.append(\\\"g\\\").attr(\\\"transform\\\", `translate(0, ${height/2})`).call(axisLin);\\nsvg.append(\\\"g\\\").attr(\\\"transform\\\", `translate(0, ${3*height/4})`).call(axisLinInv);\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nScalers created with d3.scale* family of functions play important role in translating the virtual coordiantes into pixel coordinates within the SVG node.\nOnce the scaler is defined, we can use it to create an axis. Note, that by default, the axis will be placed at the (0, 0) coordinate of its parent and we have to change this behaviour by adding a new generic element <g> and move it to the desired place using transform attribute. Here, we use the height of the plotting area to place the horizontal axes in equal distances.\nDrawing lines\nTo draw the lines, circles, and text we can use the specified SVG elements such as <line>, <circle>.\nsvg.append(\"line\")\n  .attr(\"stroke\", \"black\")\n  .attr(\"stroke-width\", 3)\n  .attr(\"x1\", 50).attr(\"y1\", height-50)\n  .attr(\"x2\", width-50).attr(\"y2\", 50);\n\nvar centres = [[50, height-50], [width-50, 50]];\n\nsvg.append(\"g\")\n  .selectAll(\"circle\")\n  .data(centres).enter()\n  .append(\"circle\")\n    .attr(\"r\", 7)\n    .attr(\"cx\", d => d[0])\n    .attr(\"cy\", d => d[1])\n    .attr(\"stroke\", \"none\")\n    .attr(\"fill\", \"red\");\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nsvg.append(\\\"line\\\")\\n  .attr(\\\"stroke\\\", \\\"black\\\")\\n  .attr(\\\"stroke-width\\\", 3)\\n  .attr(\\\"x1\\\", 50).attr(\\\"y1\\\", height-50)\\n  .attr(\\\"x2\\\", width-50).attr(\\\"y2\\\", 50);\\n\\nvar centres = [[50, height-50], [width-50, 50]];\\n\\nsvg.append(\\\"g\\\")\\n  .selectAll(\\\"circle\\\")\\n  .data(centres).enter()\\n  .append(\\\"circle\\\")\\n    .attr(\\\"r\\\", 7)\\n    .attr(\\\"cx\\\", d => d[0])\\n    .attr(\\\"cy\\\", d => d[1])\\n    .attr(\\\"stroke\\\", \\\"none\\\")\\n    .attr(\\\"fill\\\", \\\"red\\\");\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nDrawing lines this way is not the most efficient solution and it is better to use the turtle-like language and the d attribute of the path element. To do that, we need to keep the (x, y) coordinates stored as a touple in an array so that it looks as follows: [[x1, y1], [x2, y2], ... , [xN, yN]]. D3.js provides us with line maker factories which are automatising the like drawing and also let us decide wheter we want to use spline polynomials, connect the dots or maybe use one of the other methods from the library.\nvar margin = {top: 50, right: 50, bottom: 50, left: 50};\n\nvar data = Array.from({length: 7}, (d,i) => [i, Math.random()]);\n\nvar xScaler = d3.scaleLinear()\n  .domain([0, data.length - 1])\n  .range([margin.left, width - margin.right]);\n\nvar yScaler = d3.scaleLinear()\n  .domain([0, 1])\n  .range([height - margin.bottom, margin.top]);\n\ndata = data.map( d => [xScaler(d[0]), yScaler(d[1])]);\n\nsvg.append(\"g\")\n  .selectAll(\"circle\")\n  .data(data).enter()\n  .append(\"circle\")\n    .attr(\"r\", 7)\n    .attr(\"fill\", \"black\")\n    .attr(\"cx\", d => d[0])\n    .attr(\"cy\", d => d[1]);\n\nvar lineMaker = d3.line().curve(d3.curveNatural);\n\nsvg.append(\"g\")\n  .append(\"path\")\n  .attr(\"d\", lineMaker(data))\n  .attr(\"fill\", \"none\")\n  .attr(\"stroke\", \"steelblue\")\n  .attr(\"stroke-width\", 4);\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nvar margin = {top: 50, right: 50, bottom: 50, left: 50};\\n\\nvar data = Array.from({length: 7}, (d,i) => [i, Math.random()]);\\n\\nvar xScaler = d3.scaleLinear()\\n  .domain([0, data.length - 1])\\n  .range([margin.left, width - margin.right]);\\n\\nvar yScaler = d3.scaleLinear()\\n  .domain([0, 1])\\n  .range([height - margin.bottom, margin.top]);\\n\\ndata = data.map( d => [xScaler(d[0]), yScaler(d[1])]);\\n\\nsvg.append(\\\"g\\\")\\n  .selectAll(\\\"circle\\\")\\n  .data(data).enter()\\n  .append(\\\"circle\\\")\\n    .attr(\\\"r\\\", 7)\\n    .attr(\\\"fill\\\", \\\"black\\\")\\n    .attr(\\\"cx\\\", d => d[0])\\n    .attr(\\\"cy\\\", d => d[1]);\\n\\nvar lineMaker = d3.line().curve(d3.curveNatural);\\n\\nsvg.append(\\\"g\\\")\\n  .append(\\\"path\\\")\\n  .attr(\\\"d\\\", lineMaker(data))\\n  .attr(\\\"fill\\\", \\\"none\\\")\\n  .attr(\\\"stroke\\\", \\\"steelblue\\\")\\n  .attr(\\\"stroke-width\\\", 4);\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nHandling of events\nSo far we discussed how to use scalers, add axes to the plot and how to plot a line. One vital functionality that we have to add to the widged is how to respond to the mouse events such as mouseover or click.\nvar circle = svg.append(\"circle\")\n  .attr(\"r\", 50)\n  .attr(\"cx\", width/2)\n  .attr(\"cy\", height/2)\n  .attr(\"fill\", \"gray\")\n  .on(\"click\", function(event) {\n      var el = d3.select(this);\n      var col = el.attr(\"fill\");\n      el.attr(\"fill\", () => col === \"gray\"?\"black\":\"gray\");\n  });\n\nsvg.append(\"text\")\n  .attr(\"font-family\", \"sans-serif\")\n  .attr(\"font-size\", 24)\n  .attr(\"text-anchor\", \"middle\")\n  .attr(\"x\", width/2).attr(\"y\", height/2 + 10)\n  .attr(\"fill\", \"white\")\n  .text(\"click!\");\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\n    var circle = svg.append(\\\"circle\\\")\\n      .attr(\\\"r\\\", 50)\\n      .attr(\\\"cx\\\", width/2)\\n      .attr(\\\"cy\\\", height/2)\\n      .attr(\\\"fill\\\", \\\"gray\\\")\\n      .on(\\\"click\\\", function(event) {\\n          var el = d3.select(this);\\n          var col = el.attr(\\\"fill\\\");\\n          el.attr(\\\"fill\\\", () => col === \\\"gray\\\"?\\\"black\\\":\\\"gray\\\");\\n      });\\n\\n    svg.append(\\\"text\\\")\\n        .attr(\\\"font-family\\\", \\\"sans-serif\\\")\\n        .attr(\\\"font-size\\\", 24)\\n        .attr(\\\"text-anchor\\\", \\\"middle\\\")\\n        .attr(\\\"x\\\", width/2).attr(\\\"y\\\", height/2 + 10)\\n        .attr(\\\"fill\\\", \\\"white\\\")\\n        .text(\\\"click!\\\");\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nDrag and drop\nThe last missing element that has been used to build our widget is the drag-and-drop functionality. To add drag behaviour to the application we use the d3.drag() factory function and specify what actions we want to take when the drag action is started, performed and finished. Then we call the drag factory function with the desired node as a parameter.\nvar hud = svg.append(\"text\")\n  .attr(\"x\", 50).attr(\"y\", 50)\n  .attr(\"visibility\", \"hidden\");\n\nvar dragon = svg.append(\"g\");\n\nvar circle = dragon.append(\"circle\")\n  .attr(\"r\", 10)\n  .attr(\"cx\", width/2)\n  .attr(\"cy\", height/2)\n  .attr(\"fill\", \"black\");\n\nvar pointer = dragon.append(\"text\")\n  .attr(\"x\", width/2+7)\n  .attr(\"y\", height/2+37)\n  .attr(\"font-size\", 48)\n  .attr(\"text-anchor\", \"middle\")\n  .text(\"👆\");\n\nvar drag = d3.drag()\n  .on(\"start\", function(event) {\n    pointer.attr(\"visibility\", \"hidden\");\n    hud.text(\"Drag event started...\")\n      .attr(\"visibility\", \"visible\");\n  })\n  .on(\"drag\", function(event) {\n    var pos = d3.pointer(event, svg.node());\n\n    circle.attr(\"cx\", pos[0]).attr(\"cy\", pos[1]);\n    pointer.attr(\"x\", pos[0] + 7).attr(\"y\", pos[1] + 37);\n\n    hud.text(\"You are dragging the element...\");\n\n  })\n  .on(\"end\", function() {\n    pointer.attr(\"visibility\", \"visible\");\n\n    hud.text(\"Drag event stopped...\");\n\n    d3.timeout(function() {\n        hud.attr(\"visibility\", \"hidden\");\n    }, 1000);\n  })\n\ndrag(dragon);\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nvar hud = svg.append(\\\"text\\\")\\n  .attr(\\\"x\\\", 50).attr(\\\"y\\\", 50)\\n  .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\nvar dragon = svg.append(\\\"g\\\");\\n\\nvar circle = dragon.append(\\\"circle\\\")\\n  .attr(\\\"r\\\", 10)\\n  .attr(\\\"cx\\\", width/2)\\n  .attr(\\\"cy\\\", height/2)\\n  .attr(\\\"fill\\\", \\\"black\\\");\\n\\nvar pointer = dragon.append(\\\"text\\\")\\n  .attr(\\\"x\\\", width/2+7)\\n  .attr(\\\"y\\\", height/2+37)\\n  .attr(\\\"font-size\\\", 48)\\n  .attr(\\\"text-anchor\\\", \\\"middle\\\")\\n  .text(\\\"👆\\\");\\n\\nvar drag = d3.drag()\\n  .on(\\\"start\\\", function(event) {\\n    pointer.attr(\\\"visibility\\\", \\\"hidden\\\");\\n    hud.text(\\\"Drag event started...\\\")\\n      .attr(\\\"visibility\\\", \\\"visible\\\");\\n  })\\n  .on(\\\"drag\\\", function(event) {\\n    var pos = d3.mouse(svg.node());\\n\\n    circle.attr(\\\"cx\\\", pos[0]).attr(\\\"cy\\\", pos[1]);\\n    pointer.attr(\\\"x\\\", pos[0] + 7).attr(\\\"y\\\", pos[1] + 37);\\n\\n    hud.text(\\\"You are dragging the element...\\\");\\n\\n  })\\n  .on(\\\"end\\\", function() {\\n    pointer.attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n    hud.text(\\\"Drag event stopped...\\\");\\n\\n    d3.timeout(function() {\\n        hud.attr(\\\"visibility\\\", \\\"hidden\\\");\\n    }, 1000);\\n  })\\n\\ndrag(dragon);\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nFinal notes\nD3.js can be used to create interactive documents from within the RStudio environment by using the r2d3 package. This website was created in markdown and the d3js code chunks were added and executed from within. For more information go to r2d3 website.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-05-23T13:24:33+01:00",
    "input_file": {}
  }
]
