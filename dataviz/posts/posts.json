[
  {
    "path": "posts/2021-05-22-a-brief-introduction-to-d3js-for-data-scientists/",
    "title": "D3.js in Statistics",
    "description": "A brief introduction to D3.js.",
    "author": [
      {
        "name": "Pawel Piela",
        "url": {}
      }
    ],
    "date": "2021-05-22",
    "categories": [
      "d3js"
    ],
    "contents": "\nThose who used both Python or R to perform their statistical inference, or build the machine learning models know, that these environments together with their rich libraries can enable the practitioner to do anything they want. They are great for prototyping and performing experiments. Python in conjunction with Django or Flask can be used to build a fully contained web applications. R with it’s Shiny environment can be used to build interactive dashboards. The shortcoming is that these applications have to run on the server and the resources has to be purchased before the content is shared to a wider audience. One of the solutions to this is to use the audience and their computing power to transform and present the data.\nI have some experience in using R and Python. The main issue I have encountered is that making a move from the experimental phase to publishing is always difficult. After the project is concluded many times it goes back to the drawer, because publishing it would require paying for the computational power or the cloud providers.\nD3.js\nD3.js is a JavaScript framework used to create data driven interactive documents. It is not a graphical library, that can be used to create the interactive content quickly. But once it is mastered, it becomes invaluable help in publishing interactive documents. D3.js is used to create many visually appealing and informative visualisations Observable.\nExample\nHere, we will built an interactive D3.js widget which plots an arbitrary function and calculates the integral under the selected part of the plot. We will use the probability density function of the normal distribution and let the widget calculate the area under two specified x values i.e. the probability.\nfunction f(x) {\n    // standard normal pdf\n    return (1/Math.sqrt(2*Math.PI))*Math.exp(-x*x/2);\n}\n\\[\\begin{equation}\np(x; 0, 1) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left( -\\frac{x^2}{2} \\right)\n\\end{equation}\\]\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\n\\nfunction f(x) {\\n    return (1/Math.sqrt(2*Math.PI))*Math.exp(-x*x/2);\\n}\\n\\nfunction trapInt(fx, dx) {\\n    fxN1 = _.initial(fx);\\n    sumFx = fxN1.reduce((a, v) => a+v);\\n    return dx*(sumFx + (fx[0] + fx[fx.length - 1])/2);\\n}\\n\\nfunction main() {\\n\\n    var dx = 1/50; // granuality of the chart\\n    var margins = {top: 20, right: 10, bottom: 50, left: 10};\\n\\n    var xVals = d3.range(-5, 5, dx); // x\\n    var yVals = xVals.map( x => f(x)); // f(x)\\n\\n    // define the scales\\n    var scX = d3.scaleLinear()\\n      .domain(d3.extent(xVals))\\n      .range([margins.left, width - margins.right])\\n      .nice();\\n\\n    var scY = d3.scaleLinear()\\n      .domain(d3.extent(yVals))\\n      .range([height - margins.bottom, margins.top])\\n      .nice();\\n\\n    // scale x and f(x) to the screen coordinates\\n    var data = xVals.map( (d, i) => [scX(d), scY(yVals[i])]);\\n\\n    // create axes\\n    var xAxis = d3.axisBottom(scX);\\n    var yAxis = d3.axisLeft(scY);\\n    \\n    var foreground  = svg.append(\\\"g\\\").append(\\\"rect\\\")\\n      .attr(\\\"x\\\", 0).attr(\\\"y\\\", 0)\\n      .attr(\\\"width\\\", width).attr(\\\"height\\\", height)\\n      .attr(\\\"opacity\\\", 0);\\n\\n    // add axes to the svg component\\n    svg.append(\\\"g\\\")\\n      .attr(\\\"transform\\\", `translate(0, ${scY(0)})`)\\n      .call(xAxis);\\n    \\n    svg.append(\\\"g\\\")\\n      .attr(\\\"transform\\\", `translate(${scX(0)}, 0)`)\\n      .call(yAxis);\\n\\n\\n    // plot\\n    var lineMkr = d3.line().curve(d3.curveLinear);\\n\\n    // line\\n    var chart = svg.append(\\\"g\\\")\\n      .append(\\\"path\\\")\\n      .attr(\\\"d\\\", lineMkr(data))\\n      .attr(\\\"fill\\\", \\\"none\\\")\\n      .attr(\\\"stroke\\\", \\\"orange\\\")\\n      .attr(\\\"stroke-width\\\", 2);\\n\\n    // cooridiates text\\n    var coord = svg.append(\\\"text\\\")\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    // currently selected value\\n    var circle = svg.append(\\\"g\\\")\\n      .append(\\\"circle\\\")\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    // add event listeners\\n    svg.on(\\\"mousemove\\\", function(event) {\\n        var pt = d3.mouse(svg.node()); // point in the svg component coordinates\\n\\n        // get coordinates of the selected point\\n        var xPos = _.clamp(scX.invert(pt[0]), d3.min(xVals), d3.max(xVals));\\n        var yPos = f(xPos);\\n\\n        // draw \\n        circle\\n          .attr(\\\"r\\\", 5)\\n          .attr(\\\"cx\\\", scX(xPos))\\n          .attr(\\\"cy\\\", scY(yPos))\\n          .attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n        // format displayed coordinates text\\n        var txtPos = `(${d3.format(\\\".2f\\\")(xPos)}, ${d3.format(\\\".2f\\\")(yPos)})`;\\n\\n        coord\\n          .attr(\\\"x\\\", pt[0] > width/2 ? scX(xPos) - 10 : scX(xPos) + 10)\\n          .attr(\\\"y\\\", scY(yPos))\\n          .attr(\\\"visibility\\\", \\\"visible\\\")\\n          .attr(\\\"text-anchor\\\", pt[0] > width/2 ? \\\"end\\\" : \\\"start\\\")\\n          .text(txtPos);\\n    })\\n    .on(\\\"mouseout\\\", function(event) {\\n        // hide the circle an the associated text\\n        circle.attr(\\\"visibility\\\", \\\"hidden\\\");\\n        coord.attr(\\\"visibility\\\", \\\"hidden\\\");\\n    });\\n\\n    // SELECT THE AREA\\n\\n    // define the closed selection\\n    var selectionMaker = d3.line().curve(d3.curveLinearClosed);\\n\\n    var selectionSvg = svg.append(\\\"g\\\")\\n      .append(\\\"path\\\")\\n      .attr(\\\"fill\\\", \\\"steelblue\\\")\\n      .attr(\\\"opacity\\\", .2)\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    // display the area\\n    var txtArea = svg.append(\\\"g\\\")\\n      .append(\\\"text\\\")\\n      .attr(\\\"x\\\", 50)\\n      .attr(\\\"y\\\", 50)\\n      .attr(\\\"font-family\\\", \\\"sans-serif\\\")\\n      .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\n    var dragStart; // x screen coordinate\\n    var dragEnd;  // x screen coordinate\\n    var selectionIdx; // boolean vector indicating which data values are being used in selection\\n    var h0 = scY(0); // y=0 in screen coordinates\\n\\n    // on click hide the selection and displayed area\\n    svg.on(\\\"click\\\", function(event) {\\n        selectionSvg.attr(\\\"visibility\\\", \\\"hidden\\\");\\n        txtArea.attr(\\\"visibility\\\", \\\"hidden\\\");\\n        dragStart = undefined;\\n    });\\n\\n    // define the drag behaviour\\n    var drag = d3.drag()\\n      .on(\\\"start\\\", function(event) {\\n          dragStart = d3.mouse(svg.node())[0];\\n          dragEnd = dragStart;\\n      })\\n      .on(\\\"drag\\\", function(event) {\\n        var pt = d3.mouse(svg.node());\\n\\n        dragEnd = pt[0]; // end selection at the current x poisition\\n        \\n        console.log(\\\"From \\\" + dragStart + \\\" to \\\" + dragEnd);\\n\\n        // to reduce errors due to the granuality\\n        // calculate exact start and end coordinates\\n        var exactStartY = scY(f(scX.invert(dragStart)));\\n        var exactEndY = scY(f(scX.invert(dragEnd)));\\n\\n        // determine which data points are included in the selection\\n        selectionIdx = data.map( d => _.inRange(d[0], dragStart, dragEnd));\\n\\n        // select only relevant slice of the chart data\\n        var selection = data.filter( (d, i) => selectionIdx[i]);\\n\\n        // add the additional points to close the curve\\n        add2Sel = [[dragEnd, h0], [dragStart, h0]].sort( (a, b) => b[0] - a[0]);\\n        addExact = [[dragEnd, exactEndY], [dragStart, exactStartY]].sort( (a, b) => b[0] - a[0]);\\n\\n        add2Sel = _.concat([addExact[0]], add2Sel, [addExact[1]]);\\n        selection = _.concat(selection, add2Sel);\\n        \\n        // draw the selection\\n        selectionSvg\\n          .attr(\\\"d\\\", selectionMaker(selection))\\n          .attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n        // update the position of the circle while dragging\\n\\n        var xPos = _.clamp(scX.invert(pt[0]), d3.min(xVals), d3.max(xVals));\\n        var yPos = f(xPos);\\n\\n        circle\\n            .attr(\\\"r\\\", 5)\\n            .attr(\\\"cx\\\", scX(xPos))\\n            .attr(\\\"cy\\\", scY(yPos))\\n            .attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n        var txtPos = `(${d3.format(\\\".2f\\\")(xPos)}, ${d3.format(\\\".2f\\\")(yPos)})`;\\n\\n        coord\\n            .attr(\\\"x\\\", pt[0] > width/2 ? scX(xPos) - 10 : scX(xPos) + 10)\\n            .attr(\\\"y\\\", scY(yPos))\\n            .attr(\\\"visibility\\\", \\\"visible\\\")\\n            .attr(\\\"text-anchor\\\", pt[0] > width/2 ? \\\"end\\\" : \\\"start\\\")\\n            .text(txtPos);\\n      })\\n      .on(\\\"end\\\", function() {\\n          var fx = yVals.filter( (d, i) => selectionIdx[i] );\\n\\n          if (fx.length > 1) {\\n              txtArea.text(\\\"Selected Area: \\\" + d3.format(\\\".3f\\\")(trapInt(fx, dx)))\\n                .attr(\\\"visibility\\\", \\\"visible\\\");\\n          }\\n      });\\n\\n    // add the dragging behaviour to the svg element\\n    drag(foreground);\\n\\n}\\n\\nmain();\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nThe CDF of the normal distribution does not have a closed form and is defined as:\n\\[\n\\text{CDF} = \\frac{1}{2} \\left[ 1 + \\text{erf} \\left( \\frac{x-\\mu}{\\sigma \\sqrt{2}} \\right) \\right]\n\\] Where,\n\\[\n\\text{erf}\\ z = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2}\\ dt\n\\]\nThe usual method to calculate the CDF would involve using the statistical software such as R, e.g. \\(P(-1 < X < 1) =\\) pnorm(1) - pnorm(-1) = 0.6826895, or can be read from the statistical tables.\nIn this example we use the trapezoidal rule to calculate the approximate area under the curve:\n\\[\n\\int_a^b f(x)\\ dx \\approx \\Delta x \\left( \\sum\\limits_{k=1}^{N-1} x_k + \\frac{f(x_N)+f(x_0)}{2} \\right)\n\\]\nSVG\nD3.js can manipualte the whole DOM document structure, but we are interested in plotting by using the SVG format. First we have to add <svg><\/svg> block to the DOM structure as a child of <body> element.\nvar svg = d3.select(\"body\").append(\"svg\")\n            .attr(\"width\", 600).attr(\"height\", 600);\nHere we selected the <body> element and added <svg> as one of it’s children. We also set the width to 600px and height to 600px.\nAnother very important elements of D3.js scripts are scales\nvar scalerLin = d3.scaleLinear()\n  .domain([0, 1])\n  .range([10, width-10])\n  .nice();\n  \nvar scalerLog = d3.scaleLog()\n  .domain([1e-3, 1e6])\n  .range([10, width-10])\n  .nice();\n  \nvar scalerLinInv = d3.scaleLinear()\n  .domain([0, 1])\n  .range([width-10, 10])\n  .nice();\n\nvar axisLin = d3.axisTop(scalerLin);\nvar axisLog = d3.axisTop(scalerLog);\nvar axisLinInv = d3.axisTop(scalerLinInv);\n\nsvg.append(\"g\").attr(\"transform\", `translate(0, ${height/4})`).call(axisLog);\nsvg.append(\"g\").attr(\"transform\", `translate(0, ${height/2})`).call(axisLin);\nsvg.append(\"g\").attr(\"transform\", `translate(0, ${3*height/4})`).call(axisLinInv);\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nvar scalerLin = d3.scaleLinear()\\n  .domain([0, 1])\\n  .range([10, width-10])\\n  .nice();\\n  \\nvar scalerLog = d3.scaleLog()\\n  .domain([1e-3, 1e6])\\n  .range([10, width-10])\\n  .nice();\\n  \\nvar scalerLinInv = d3.scaleLinear()\\n  .domain([0, 1])\\n  .range([width-10, 10])\\n  .nice();\\n\\nvar axisLin = d3.axisTop(scalerLin);\\nvar axisLog = d3.axisTop(scalerLog);\\nvar axisLinInv = d3.axisTop(scalerLinInv);\\n\\nsvg.append(\\\"g\\\").attr(\\\"transform\\\", `translate(0, ${height/4})`).call(axisLog);\\nsvg.append(\\\"g\\\").attr(\\\"transform\\\", `translate(0, ${height/2})`).call(axisLin);\\nsvg.append(\\\"g\\\").attr(\\\"transform\\\", `translate(0, ${3*height/4})`).call(axisLinInv);\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nScalers created with d3.scale* family of functions play important role in translating the virtual coordiantes into pixel coordinates within the SVG node.\nOnce the scaler is defined, we can use it to create an axis. Note, that by default, the axis will be placed at the (0, 0) coordinate of its parent and we have to change this behaviour by adding a new generic element <g> and move it to the desired place using transform attribute. Here, we use the height of the plotting area to place the horizontal axes in equal distances.\nDrawing lines\nTo draw the lines, circles, and text we can use the specified SVG elements such as <line>, <circle>.\nsvg.append(\"line\")\n  .attr(\"stroke\", \"black\")\n  .attr(\"stroke-width\", 3)\n  .attr(\"x1\", 50).attr(\"y1\", height-50)\n  .attr(\"x2\", width-50).attr(\"y2\", 50);\n\nvar centres = [[50, height-50], [width-50, 50]];\n\nsvg.append(\"g\")\n  .selectAll(\"circle\")\n  .data(centres).enter()\n  .append(\"circle\")\n    .attr(\"r\", 7)\n    .attr(\"cx\", d => d[0])\n    .attr(\"cy\", d => d[1])\n    .attr(\"stroke\", \"none\")\n    .attr(\"fill\", \"red\");\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nsvg.append(\\\"line\\\")\\n  .attr(\\\"stroke\\\", \\\"black\\\")\\n  .attr(\\\"stroke-width\\\", 3)\\n  .attr(\\\"x1\\\", 50).attr(\\\"y1\\\", height-50)\\n  .attr(\\\"x2\\\", width-50).attr(\\\"y2\\\", 50);\\n\\nvar centres = [[50, height-50], [width-50, 50]];\\n\\nsvg.append(\\\"g\\\")\\n  .selectAll(\\\"circle\\\")\\n  .data(centres).enter()\\n  .append(\\\"circle\\\")\\n    .attr(\\\"r\\\", 7)\\n    .attr(\\\"cx\\\", d => d[0])\\n    .attr(\\\"cy\\\", d => d[1])\\n    .attr(\\\"stroke\\\", \\\"none\\\")\\n    .attr(\\\"fill\\\", \\\"red\\\");\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nDrawing lines this way is not the most efficient solution and it is better to use the turtle-like language and the d attribute of the path element. To do that, we need to keep the (x, y) coordinates stored as a touple in an array so that it looks as follows: [[x1, y1], [x2, y2], ... , [xN, yN]]. D3.js provides us with line maker factories which are automatising the like drawing and also let us decide wheter we want to use spline polynomials, connect the dots or maybe use one of the other methods from the library.\nvar margin = {top: 50, right: 50, bottom: 50, left: 50};\n\nvar data = Array.from({length: 7}, (d,i) => [i, Math.random()]);\n\nvar xScaler = d3.scaleLinear()\n  .domain([0, data.length - 1])\n  .range([margin.left, width - margin.right]);\n\nvar yScaler = d3.scaleLinear()\n  .domain([0, 1])\n  .range([height - margin.bottom, margin.top]);\n\ndata = data.map( d => [xScaler(d[0]), yScaler(d[1])]);\n\nsvg.append(\"g\")\n  .selectAll(\"circle\")\n  .data(data).enter()\n  .append(\"circle\")\n    .attr(\"r\", 7)\n    .attr(\"fill\", \"black\")\n    .attr(\"cx\", d => d[0])\n    .attr(\"cy\", d => d[1]);\n\nvar lineMaker = d3.line().curve(d3.curveNatural);\n\nsvg.append(\"g\")\n  .append(\"path\")\n  .attr(\"d\", lineMaker(data))\n  .attr(\"fill\", \"none\")\n  .attr(\"stroke\", \"steelblue\")\n  .attr(\"stroke-width\", 4);\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nvar margin = {top: 50, right: 50, bottom: 50, left: 50};\\n\\nvar data = Array.from({length: 7}, (d,i) => [i, Math.random()]);\\n\\nvar xScaler = d3.scaleLinear()\\n  .domain([0, data.length - 1])\\n  .range([margin.left, width - margin.right]);\\n\\nvar yScaler = d3.scaleLinear()\\n  .domain([0, 1])\\n  .range([height - margin.bottom, margin.top]);\\n\\ndata = data.map( d => [xScaler(d[0]), yScaler(d[1])]);\\n\\nsvg.append(\\\"g\\\")\\n  .selectAll(\\\"circle\\\")\\n  .data(data).enter()\\n  .append(\\\"circle\\\")\\n    .attr(\\\"r\\\", 7)\\n    .attr(\\\"fill\\\", \\\"black\\\")\\n    .attr(\\\"cx\\\", d => d[0])\\n    .attr(\\\"cy\\\", d => d[1]);\\n\\nvar lineMaker = d3.line().curve(d3.curveNatural);\\n\\nsvg.append(\\\"g\\\")\\n  .append(\\\"path\\\")\\n  .attr(\\\"d\\\", lineMaker(data))\\n  .attr(\\\"fill\\\", \\\"none\\\")\\n  .attr(\\\"stroke\\\", \\\"steelblue\\\")\\n  .attr(\\\"stroke-width\\\", 4);\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nHandling of events\nSo far we discussed how to use scalers, add axes to the plot and how to plot a line. One vital functionality that we have to add to the widged is how to respond to the mouse events such as mouseover or click.\nvar circle = svg.append(\"circle\")\n  .attr(\"r\", 50)\n  .attr(\"cx\", width/2)\n  .attr(\"cy\", height/2)\n  .attr(\"fill\", \"gray\")\n  .on(\"click\", function(event) {\n      var el = d3.select(this);\n      var col = el.attr(\"fill\");\n      el.attr(\"fill\", () => col === \"gray\"?\"black\":\"gray\");\n  });\n\nsvg.append(\"text\")\n  .attr(\"font-family\", \"sans-serif\")\n  .attr(\"font-size\", 24)\n  .attr(\"text-anchor\", \"middle\")\n  .attr(\"x\", width/2).attr(\"y\", height/2 + 10)\n  .attr(\"fill\", \"white\")\n  .text(\"click!\");\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\n    var circle = svg.append(\\\"circle\\\")\\n      .attr(\\\"r\\\", 50)\\n      .attr(\\\"cx\\\", width/2)\\n      .attr(\\\"cy\\\", height/2)\\n      .attr(\\\"fill\\\", \\\"gray\\\")\\n      .on(\\\"click\\\", function(event) {\\n          var el = d3.select(this);\\n          var col = el.attr(\\\"fill\\\");\\n          el.attr(\\\"fill\\\", () => col === \\\"gray\\\"?\\\"black\\\":\\\"gray\\\");\\n      });\\n\\n    svg.append(\\\"text\\\")\\n        .attr(\\\"font-family\\\", \\\"sans-serif\\\")\\n        .attr(\\\"font-size\\\", 24)\\n        .attr(\\\"text-anchor\\\", \\\"middle\\\")\\n        .attr(\\\"x\\\", width/2).attr(\\\"y\\\", height/2 + 10)\\n        .attr(\\\"fill\\\", \\\"white\\\")\\n        .text(\\\"click!\\\");\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nDrag and drop\nThe last missing element that has been used to build our widget is the drag-and-drop functionality. To add drag behaviour to the application we use the d3.drag() factory function and specify what actions we want to take when the drag action is started, performed and finished. Then we call the drag factory function with the desired node as a parameter.\nvar hud = svg.append(\"text\")\n  .attr(\"x\", 50).attr(\"y\", 50)\n  .attr(\"visibility\", \"hidden\");\n\nvar dragon = svg.append(\"g\");\n\nvar circle = dragon.append(\"circle\")\n  .attr(\"r\", 10)\n  .attr(\"cx\", width/2)\n  .attr(\"cy\", height/2)\n  .attr(\"fill\", \"black\");\n\nvar pointer = dragon.append(\"text\")\n  .attr(\"x\", width/2+7)\n  .attr(\"y\", height/2+37)\n  .attr(\"font-size\", 48)\n  .attr(\"text-anchor\", \"middle\")\n  .text(\"👆\");\n\nvar drag = d3.drag()\n  .on(\"start\", function(event) {\n    pointer.attr(\"visibility\", \"hidden\");\n    hud.text(\"Drag event started...\")\n      .attr(\"visibility\", \"visible\");\n  })\n  .on(\"drag\", function(event) {\n    var pos = d3.pointer(event, svg.node());\n\n    circle.attr(\"cx\", pos[0]).attr(\"cy\", pos[1]);\n    pointer.attr(\"x\", pos[0] + 7).attr(\"y\", pos[1] + 37);\n\n    hud.text(\"You are dragging the element...\");\n\n  })\n  .on(\"end\", function() {\n    pointer.attr(\"visibility\", \"visible\");\n\n    hud.text(\"Drag event stopped...\");\n\n    d3.timeout(function() {\n        hud.attr(\"visibility\", \"hidden\");\n    }, 1000);\n  })\n\ndrag(dragon);\n\n\n{\"x\":{\"data\":null,\"type\":\"NULL\",\"container\":\"svg\",\"options\":null,\"script\":\"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\\nthis.d3 = d3;\\n\\nsvg = d3.select(svg.node());\\nvar hud = svg.append(\\\"text\\\")\\n  .attr(\\\"x\\\", 50).attr(\\\"y\\\", 50)\\n  .attr(\\\"visibility\\\", \\\"hidden\\\");\\n\\nvar dragon = svg.append(\\\"g\\\");\\n\\nvar circle = dragon.append(\\\"circle\\\")\\n  .attr(\\\"r\\\", 10)\\n  .attr(\\\"cx\\\", width/2)\\n  .attr(\\\"cy\\\", height/2)\\n  .attr(\\\"fill\\\", \\\"black\\\");\\n\\nvar pointer = dragon.append(\\\"text\\\")\\n  .attr(\\\"x\\\", width/2+7)\\n  .attr(\\\"y\\\", height/2+37)\\n  .attr(\\\"font-size\\\", 48)\\n  .attr(\\\"text-anchor\\\", \\\"middle\\\")\\n  .text(\\\"👆\\\");\\n\\nvar drag = d3.drag()\\n  .on(\\\"start\\\", function(event) {\\n    pointer.attr(\\\"visibility\\\", \\\"hidden\\\");\\n    hud.text(\\\"Drag event started...\\\")\\n      .attr(\\\"visibility\\\", \\\"visible\\\");\\n  })\\n  .on(\\\"drag\\\", function(event) {\\n    var pos = d3.mouse(svg.node());\\n\\n    circle.attr(\\\"cx\\\", pos[0]).attr(\\\"cy\\\", pos[1]);\\n    pointer.attr(\\\"x\\\", pos[0] + 7).attr(\\\"y\\\", pos[1] + 37);\\n\\n    hud.text(\\\"You are dragging the element...\\\");\\n\\n  })\\n  .on(\\\"end\\\", function() {\\n    pointer.attr(\\\"visibility\\\", \\\"visible\\\");\\n\\n    hud.text(\\\"Drag event stopped...\\\");\\n\\n    d3.timeout(function() {\\n        hud.attr(\\\"visibility\\\", \\\"hidden\\\");\\n    }, 1000);\\n  })\\n\\ndrag(dragon);\\n};\",\"style\":null,\"version\":5,\"theme\":{\"default\":{\"background\":\"#FFFFFF\",\"foreground\":\"#000000\"},\"runtime\":null},\"useShadow\":true},\"evals\":[],\"jsHooks\":[]}\nFinal notes\nD3.js can be used to create interactive documents from within the RStudio environment by using the r2d3 package. This website was created in markdown and the d3js code chunks were added and executed from within. For more information go to r2d3 website.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-05-23T13:24:33+01:00",
    "input_file": {}
  }
]
